##### nextTick （src/core/util/next-tick.js）
nextTick简而言之就是 维护了一个任务队列，通过异步方法执行这个队列

- pending *标识是否在执行回调函数*
- callbacks  *任务队列*
- flushCallbacks *按顺序执行队列*
- timerFunc *异步执行方法*

每次执行nextTick将回调都存入`callbacks`队列中，同时判断`pending`,timerFunc是否已经执行，如果pending是false那么执行`timeFunc`（异步方法 会采用优雅降级策略选取一个支持的异步方法），多次执行nextTick只会执行一次 `timerFunc`方法，但会把回调都放入`callbacks`任务队列中，最后也就是按顺序执行`flushCallbacks`中的回调，并清空队列

```
export let isUsingMicroTask = false
const callbacks = [] // 维护的队列集合
let pending = false

// 按照队列顺序执行回调
function flushCallbacks () {
  pending = false
  const copies = callbacks.slice(0)
  callbacks.length = 0
  for (let i = 0; i < copies.length; i++) {
    copies[i]()
  }
}

let timerFunc

/**
 * vue中的 nextTick没有直接采用某个api 而是采用优雅降级的方式
 * 内部首先采用promise(ie 不兼容) MutationObserver(h5 的api)  ie专项 setImmediate
 */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  const p = Promise.resolve()
  timerFunc = () => {
    p.then(flushCallbacks)
    // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) setTimeout(noop)
  }
  isUsingMicroTask = true
} else if (!isIE && typeof MutationObserver !== 'undefined' && (
  isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  let counter = 1
  const observer = new MutationObserver(flushCallbacks)
  const textNode = document.createTextNode(String(counter))
  observer.observe(textNode, {
    characterData: true
  })
  timerFunc = () => {
    counter = (counter + 1) % 2
    textNode.data = String(counter)
  }
  isUsingMicroTask = true
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = () => {
    setImmediate(flushCallbacks)
  }
} else {
  // Fallback to setTimeout.
  timerFunc = () => {
    setTimeout(flushCallbacks, 0)
  }
}

// nextTick 不是维护了一个异步任务   而是将这个任务维护到了队列中
export function nextTick (cb?: Function, ctx?: Object) {
  let _resolve
  callbacks.push(() => {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true
    timerFunc()
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve
    })
  }
}

```

##### DOM异步更新策略
起因：每次操作属性都会导致更新，操作属性次数过多，更新次数也会过多，导致性能等

思路：借鉴`nextTick`实现方式，通过异步的方式维护一份队列

  - queueWatcher *将watcher推入队列中*
  - waiting *标识是否在执行*
  - has *watcher记录防止重复推入队列中*
  - queue *记录watcher的队列*
  - flushSchedulerQueue *按顺序执行队列*

###### wathcer.js （src/core/observer/wathcer.js）
当响应式数据发生变化，属性的setter函数会通知闭包中的Dep，`Dep`则会调用它管理的所有的`Watcher`对象，并触发`Watcher`对象的update方法。（Vue默认使用DOM异步更新策略）
```
/**
  * Subscriber interface.
  * Will be called when a dependency changes.
  * 调度者接口，当依赖发生改变的时候进行回调。
  */
update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true
  } else if (this.sync) { /*同步则执行run直接渲染视图*/
    this.run()
  } else {
    /*异步推送到观察者队列中，下一个tick时调用。*/
    queueWatcher(this)
  }
}
```

###### scheduler.js （src/core/observer/scheduler.js）
queueWatcher将每次属性变化所关联的`Watcher`记录起来，并记录id防止队列重复添加`Watcher`，同时判断`waiting`,nextTick是否已经执行, 如果`waiting`是false，那么执行`nextTick`,多次的属性变化只会执行一次`nextTick`，但会把`Wathcer`（未记录的）记录到队列中，最后就是执行`flushSchedulerQueue`（即按顺序执行`watcher.run`方法），并清空队列

```
const queue: Array<Watcher> = []
/*一个哈希表，用来存放watcher对象的id，防止重复的watcher对象多次加入*/
let has: { [key: number]: ?true } = {}
let waiting = false

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 * *将观察者推入观察者队列。具有重复ID的作业将被跳过，除非在刷新队列时推送。
 */
export function queueWatcher (watcher: Watcher) {
  const id = watcher.id /*获取watcher的id*/

  // 判断watcher id是否已经记录过，防止重复刷新
  if (has[id] == null) {
    has[id] = true
    if (!flushing) {
      queue.push(watcher)
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      let i = queue.length - 1
      while (i > index && queue[i].id > watcher.id) {
        i--
      }
      queue.splice(i + 1, 0, watcher)
    }
    /**
     * queue the flush
     * 多次修改属性的值  只会执行一次
     * 不论update执行多少次 但是最终只执行一轮刷新操作
     */
    if (!waiting) {
      waiting = true

      if (process.env.NODE_ENV !== 'production' && !config.async) {
        flushSchedulerQueue()
        return
      }
      nextTick(flushSchedulerQueue)
    }
  }
}


/**
 * Flush both queues and run the watchers.
 * 执行队列中所有的watcher
 */
function flushSchedulerQueue () {
  currentFlushTimestamp = getNow()
  flushing = true
  let watcher, id

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  /*
    给queue排序，这样做可以保证：
    1.组件更新的顺序是从父组件到子组件的顺序，因为父组件总是比子组件先创建。
    2.一个组件的user watchers比render watcher先运行，因为user watchers往往比render watcher更早创建
    3.如果一个组件在父组件watcher运行期间被销毁，它的watcher执行将被跳过。
  */
  queue.sort((a, b) => a.id - b.id)

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  /*这里不用index = queue.length;index > 0; index--的方式写是因为不要将length进行缓存，因为在执行处理现有watcher对象期间，更多的watcher对象可能会被push进queue*/
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index]
    if (watcher.before) {
      watcher.before()
    }
    id = watcher.id
    has[id] = null /*将has的标记删除*/
    watcher.run()
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? `in watcher with expression "${watcher.expression}"`
              : `in a component render function.`
          ),
          watcher.vm
        )
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  const activatedQueue = activatedChildren.slice()
  const updatedQueue = queue.slice()

  /*重置调度者的状态*/
  resetSchedulerState()
  // call component updated and activated hooks /*使子组件状态都改编成active同时调用activated钩子*/
  callActivatedHooks(activatedQueue)
  /*调用updated钩子*/
  callUpdatedHooks(updatedQueue)

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush')
  }
}
```