#### Vue.js 内部运行机制 [参考](https://juejin.cn/book/6844733705089449991/section/6844733705211084808)

<img height='500px' src='./images/Vue运行机制/1.png' />

##### 初始化挂载（new Vue() → $mounet）
<img height='150px' src='./images/Vue运行机制/2.png' />

```

  - new Vue()之后，Vue会调用 _init 方法来初始化（生命周期、事件、render函数、inject、provide、 props、methods、data、computed与watch等）

    - 其中最重要的是 data 数据初始化，通过Object.defineProperty “重新定义” 属性（性能有点差），对属性的getter与setter进行劫持，以及依赖收集（响应式原理：数据劫持 + 观察者模式）

  - 初始化之后就是调用 $mount 挂载组件，如果是运行时编译，则需要走编译流程（对模板进行编译,模板转换成ast语法树,ast语法树静态节点标记，将ast语法树转换成render函数 ）

    - entry-runtime.js 仅包含运行时 的源码文件

    - entry-runtime-with-compiler.js  同时包含编译器和运行时
    
```

##### 编译（模板 → ast树 →  render函数）
<img height='300px' src='./images/Vue运行机制/3.png' />

```

  - compile编译可以分成 parse、optimize 与 generate 三个阶段，最终需要得到render。

    - parse 会用正则等方式解析 template 模板中的指令、class、style等数据，形成ast。

    - optimize 静态节点标记优化，在页面更新时（patch），diff算法会直接跳过静态节点的比较，从而减少比较过程

    - generate ast语法树转换成render函数
    
```

##### 响应式（数据劫持 + 观察者模式）
<img height='400px' src='./images/Vue运行机制/4.png' />

```
  - 数据劫持的时候会在getter中使用dep进行【依赖收集】，当劫持的对象改变的时候，会触发setter，同时通知之前的【依赖收集】去通知wathcer更新视图

  - watcher 会调用update方法来更新视图（用了异步队列的策略）

  - 通过patch方法判断是否初次渲染，还是需要diff算法来比对虚拟节点差异进行视图更新
```
