##### computed （src/core/instance/state.js）
  ###### 实现
    - 1.初始化computed函数，遍历对象，给每个计算属性创建一个计算属性watcher
    - 2.定义computed函数的get,set函数
    - 3.创建计算属性控制器（createComputedGetter），并且让当前的计算属性的依赖属性去记录当前的渲染watcher，在watcher中创建计算函数，以及脏值判断逻辑
    （只有当依赖属性改变后，通知渲染watcher重新渲染，才会重新调用watcher.evaluate更新数据）

  ###### 流程
    - 1.页面首次渲染首先初始化数据，computed等等
    - 2.在执行$mount后 首先创建并pushTarget记录渲染watcher（栈存储），在页面渲染 "{{计算属性}}" 的时候会触发计算属性的get方法，如果是脏值（默认脏值）
    - 3.调用watcher.evaluate即调用get方法，通过pushTarget往栈中记录计算watcher，并执行计算属性函数
    - 4.计算属性函数中的依赖属性（observer监听属性）会去记录当前watcher即计算watcher
    - 5.依赖属性的dep记录完成后，执行计算函数得到计算结果，同时popTarget出栈当前计算属性（此时栈中就只有渲染watcher）
    - 6.此时回到了计算属性的createComputedGetter中，然后再调用watcher.depend()让当前计算属性的依赖属性记住当前的渲染watcher
    - 7.最后就是真实dom的创建以及渲染了
    - 8.如果改变了依赖属性，那么dep.notify()遍历执行watcher，首先执行计算watcher重新设置为脏值，然后执行渲染watcher接着走1-7步骤

```
// 初始化 computed函数
// 1.初始化computed函数，遍历对象，给每个计算属性创建一个计算属性watcher
// 2.定义computed函数的get,set函数
// 3.创建计算属性控制器（createComputedGetter），并且让当前的计算属性的依赖属性去记录当前的渲染watcher，在watcher中创建计算函数，以及脏值判断逻辑
//（只有当依赖属性改变后，通知渲染watcher重新渲染，才会重新调用watcher.evaluate更新数据）
function initComputed (vm: Component, computed: Object) {
  // $flow-disable-line
  const watchers = vm._computedWatchers = Object.create(null)
  // computed properties are just getters during SSR
  const isSSR = isServerRendering()

  for (const key in computed) {
    const userDef = computed[key]

    // 计算属性可能是一个function，也有可能设置了get以及set的对象。
    const getter = typeof userDef === 'function' ? userDef : userDef.get
    if (process.env.NODE_ENV !== 'production' && getter == null) {
      warn(
        `Getter is missing for computed property "${key}".`,
        vm
      )
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      // 每个计算属性 对应一个计算属性watcher  默认lazy：true 调用一次计算属性方法watcher.evaluate 计算值
      // 此刻的计算watcher的get方法 就是当前计算属性的get方法
      watchers[key] = new Watcher(vm,getter || noop,noop,computedWatcherOptions)
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      // 当页面{{}}展示计算属性的时候，get即createComputedGetter方法执行
      defineComputed(vm, key, userDef)
    } else if (process.env.NODE_ENV !== 'production') {
      if (key in vm.$data) {
        warn(`The computed property "${key}" is already defined in data.`, vm)
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(`The computed property "${key}" is already defined as a prop.`, vm)
      } else if (vm.$options.methods && key in vm.$options.methods) {
        warn(`The computed property "${key}" is already defined as a method.`, vm)
      }
    }
  }
}


/**
 *定义计算属性 简单来说就是这个
  function defineComputed(target,key,userDef){
    const setter = userDef.set || (()=>{})
    Object.defineProperty(target,key,{
      get:createComputedGetter(key),
      set:setter
    })
  }
*/
export function defineComputed (target: any,key: string,userDef: Object | Function) {
  const shouldCache = !isServerRendering()

  // 这块总结：就是对计算属性的get和set做初始化设置
  if (typeof userDef === 'function') {
    /*创建计算属性的getter*/
    sharedPropertyDefinition.get = shouldCache? createComputedGetter(key): createGetterInvoker(userDef)
    /*
      当userDef是一个function的时候是不需要setter的，所以这边给它设置成了空函数。
      因为计算属性默认是一个function，只设置getter。
      当需要设置setter的时候，会将计算属性设置成一个对象。参考：https://v2.cn.vuejs.org/v2/guide/computed.html#计算-setter
    */
    sharedPropertyDefinition.set = noop
  } else {
    /*get不存在则直接给空函数，如果存在则查看是否有缓存cache，没有依旧赋值get，有的话使用createComputedGetter创建*/
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop

    sharedPropertyDefinition.set = userDef.set || noop
  }
  if (process.env.NODE_ENV !== 'production' &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        `Computed property "${key}" was assigned to but it has no setter.`,
        this
      )
    }
  }

  // 给计算属性设置get set
  Object.defineProperty(target, key, sharedPropertyDefinition)
}

// 创建一个计算属性控制器 用于控制页面多次调用计算属性只执行一次
// 计算属性根本不会去收集依赖，只会让自己的依赖属性去收集依赖
function createComputedGetter (key) {

  return function computedGetter () {
    const watcher = this._computedWatchers && this._computedWatchers[key] //获取到对应计算属性的watcher
    if (watcher) {
      if (watcher.dirty) {
        // 如果用户数据是脏的就去执行的函数更新数据
        watcher.evaluate()
      } 
      // 依赖收集
      if (Dep.target) {
        console.log('dep-target',Dep.target);
        watcher.depend()
      }
      return watcher.value
    }
  }
}
```

##### watch （src/core/instance/state.js）

  ###### 实现
    - 1.遍历watch对象，给每一个监听属性添加一个watch watcher
    - 2.判断值是对象还是函数，如果是对象单独处理handler
    - 3.将watch遍历的 key 做为传入watcher中，并包裹成函数赋值给getter，该函数执行的结果作为watch的旧值新值
    - 4.最后监听的属性变化，通知更新，在watcher的run函数中执行回调 

  ###### 问题：
    - watch 为什么监听不了对象里面属性的变化
      因为只对监听的目标添加了watch watcher 并没有对其属性添加,所以只有监听的整个对象改变才能够监听到
    
    - deep怎么实现的
      递归对象或数组，触发它们的 getter，使得对象或数组的每一个属性都依赖收集watch watcher，从而使得属性的变更也能触发回调 


```
// watch写法
// 1：watch:{name:'fn'}
// 2：watch:{name:()=>{}}
// 3：watch:{name:[()=>{},()=>{}]}
// 4：watch:{name:{handler(){},immediate:true}}
// 5:vm.$watch(()=>vm.name,()=>{})

function initWatch (vm: Component, watch: Object) {
  for (const key in watch) {
    const handler = watch[key]
     /*数组则遍历进行createWatcher*/
    if (Array.isArray(handler)) {
      for (let i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i])
      }
    } else {
      createWatcher(vm, key, handler)
    }
  }
}

function createWatcher (
  vm: Component,
  expOrFn: string | Function,
  handler: any,
  options?: Object
) {
  // 如果是一个对象 watch:{name:{handler(){},immediate:true}}
  if (isPlainObject(handler)) {
    options = handler
    handler = handler.handler
  }
  /*当然，也可以直接使用vm中methods的方法 */
  if (typeof handler === 'string') {
    handler = vm[handler]
  }
  return vm.$watch(expOrFn, handler, options)
}

export function stateMixin (Vue: Class<Component>) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  const dataDef = {}
  dataDef.get = function () { return this._data }
  const propsDef = {}
  propsDef.get = function () { return this._props }
  if (process.env.NODE_ENV !== 'production') {
    dataDef.set = function () {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      )
    }
    propsDef.set = function () {
      warn(`$props is readonly.`, this)
    }
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef)
  Object.defineProperty(Vue.prototype, '$props', propsDef)

  Vue.prototype.$set = set
  Vue.prototype.$delete = del

  Vue.prototype.$watch = function (
    expOrFn: string | Function,
    cb: any,
    options?: Object
  ): Function {
    const vm: Component = this
    
    // 如果回调函数是对象
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }

    options = options || {}
    options.user = true
    // 创建watch watcher
    const watcher = new Watcher(vm, expOrFn, cb, options)
    // 立即执行
    if (options.immediate) {
      const info = `callback for immediate watcher "${watcher.expression}"`
      pushTarget()
      invokeWithErrorHandling(cb, vm, [watcher.value], vm, info)
      popTarget()
    }
    /*返回一个取消观察函数，用来停止触发回调*/
    return function unwatchFn () {
      /*将自身从所有依赖收集订阅列表删除*/
      watcher.teardown()
    }
  }
}

```